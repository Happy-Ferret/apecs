#+TITLE: Entity Component System Draft
#+AUTHOR: Jonas Carpay
#+OPTIONS: todo:nil

bibliography:report.bib

* Aantekeningen
- Te veel reclame/handleiding?
- Losse StoreMembers class?
- Bewijzen dat ((a,b),c) = (a,(b,c)) = (a,b,c)?
- duidelijker cmap aantonen in introductie
- Tabellen met entities/components
- Not en Maybe eerder geven
- Het is niet zo simpel als het lijkt
- Je bent een verhaal aan het vertellen
  - Logisch colgorde secties
    - Cool things gaat van de hak op de tak
    - Wat gebeurt er als ik een tuple schrijf
- Wat voor soort queries zou je schrijven
- Functie matcht alleen op Just
- Haskell code is ook lastig
- Store associeert een k met een v
- Wat is een component -> regels
- A store over a component C is a finite partial function Ety -> C
- Globals achterwege laten for future work, net als onwetmatige lenzen
- De componenten die je gebruikt plaatsen constraints op de monad die je kan gebruiken
- apecs in titel
- makeWorld expansion is niet zo leesbaar dat ie moet blijven staan
- Uitleg kan bij Has
- Related work onderbreekt demo
- Approch en problem statement samen 1 sectie
- Ad hoc en boilerplate
- Via haskell bereiken we de drie goals
- bewijs dat cmap krachtig is
- Illustreer dat als je het niet met types doet krijg je een hoop boilerplate
- Its goals are??
- Volgorde cmap onbepaald (belangrijk voor cmapM)
- Focus op fancy cmap tricks, laat zien wat voor soort dingen je kan uitdrukken
- ECS scheidt data en code
- Misschien in Rust schrijven
- Generic mutable vector -> map
- Contributie

* Abstract
- Introduce DSL
- Describe Implementation
- Prove implementation
* Introduction [3/5]
** DONE Problem Statement
Games are often a bad fit for classical Object Oriented-style inheritance trees, and most major game engines (Unity, Unreal Engine) favor composition over inheritance using the /Component Pattern/ cite:Nystrom.
In his 2002 GDC talk, Scott Bilas presented a more data-driven approach to game development, in which ~GameObjects~ were decomposed into loosely coupled components stored in a database cite:Bilas.
This is arguably the first example of a family of architectural patterns now commonly called an /Entity Component System/ (ECS) pattern.

In an ECS, the game state consists exclusively of entities, analogous to ~GameObjects~ or actors.
An entity is a heterogeneous collection of components, and an identifier.
A component is a piece of data, without any associated code or behaviour.
Systems, finally, operate globally operate on all entities, the canonical example being a system that adds every entity's velocity to its position, for every entity that has both of those components.
We will look into what this looks like in practice in [[Approach][Approach]].

An important point to make is that in ECS libraries, the game state is not actually stored as a collection of entities (array-of-structs).
Instead, components of a single type are stored in a homogeneous collection, and the game world consists of one such collection for every component (struct-of-arrays).
We can then internally represent an entity as just the integer identifier, and use that to look up the corresponding components as necessary.
The reason this is fast is that the example system above can be compiled into an operation which only iterates over the position and velocity stores, which also allows safe parallelism of systems that operate on different data.

Unfortunately, there is no such consensus on what constitutes a system.
A common rule is that "each System runs continuously (as though each System had its own private thread) and performs global actions on every Entity that possesses a Component of the same aspect as that System." cite:Martin, but most current implementations require systems to be dispatched manually.

There are now a large number of mature ECS libraries for a variety of languages and frameworks [[Compare with existing approaches][Related Work]].
Unfortunately, none yet approach the expressivity of a domain-specific language, as all require a significant amount of verbose infrastructure.
Our goal is to investigate how much of this verbosity can be removed by leveraging strong typing.

*** TODO Nomenclature
Entity Systems, Component Entity System, ECS Framework...

** DONE Approach
In this document we will take a look at /apecs/, a simple yet powerful Entity-Component-System language embedded in Haskell.
Its goals are, in order

1. Expressivity

   ECS are unique in that game logic can be expressed in general statements about the behaviour of objects.
   This allows for uniquely concise code, and our goal is to deliver on this promise as much as possible.
   
2. Speed

   Games programming is highly performance-sensitive, as applications are required to maintain constant frame rates even with large numbers of active units.
   In order to be competitive with other implementations, ~apecs~ focuses on mutable data structures.
   
3. Safety

   Despite mutability we keep Haskell's promise of safety intact wherever possible, but not at the cost of either of the principles above.

Let's start by looking at a small code sample.
#+BEGIN_SRC haskell
-- 1.
newtype Position = Position (V2 Double)
newtype Velocity = Velocity (V2 Double)

-- 2.
instance Component Position where type Storage Position = Map Position
instance Component Velocity where type Storage Velocity = Map Velocity

-- 3.
data World = World {positions :: Storage Position, velocities :: Storage Velocity, counter :: EntityCounter}
instance Has World IO Position where getStore = System $ asks positions
instance Has World IO Velocity where getStore = System $ asks velocities
instance Has World IO EntityCounter where getStore = System $ asks counter
initWorld :: IO World
initWorld = liftM3 World initStore initStore initStore

-- 4.
game :: SystemT World IO ()
game = do
  newEntity (Position 0, Velocity 1)
  newEntity (Position 1, Velocity 1)
  cmap $ \(Position p, Velocity v) -> Position (v+p)

-- 5.
main :: IO ()
main = initWorld >>= runSystemT game
#+END_SRC

1. We start by defining the data types that we will turn into components.
2. The component instance requires you to specify the way this component is stored. For now, we will use ~Maps~, but we will look into other possible stores later.
3. These lines define the ~World~ as holding references to stores for each of our components, and a type-based mechanism for looking them up.
   The ~EntityCounter~ component is required by ~newEntity~, but not strictly necessary.
   These lines could (and should!) be generated using ~makeWorld "World" [''Position, ''Velocity]~.
4. Systems in apecs are, unsurprisingly, a monad, or more specifically a monad transformer.
   We also get our first glimpse at the composition of two components by putting them in a tuple.
   The ~cmap~ operation is a powerful operation that allows many systems to be expressed as a pure function over components.
   It is, together with the monadic variant ~cmapM_~, the main mechanism of operating on the game world.
5. Finally, we initialize our world and run our game using it.

** TODO Compare with existing approaches [0/3]
Before diving in, let's look at the two libraries that directly inspired apecs; /Entitas/ and /specs/.
These are two of the most popular open-source ECS libraries.
There are many others, but they generally follow the same principles.
Included with each is a port of the position/velocity code sample:
#+BEGIN_SRC haskell
newtype Position = Position (V2 Double)
newtype Velocity = Velocity (V2 Double)

instance Component Position where type Storage Position = Map Position
instance Component Velocity where type Storage Velocity = Map Velocity

makeWorld "World" [''Position, ''Velocity]

game :: SystemT World IO ()
game = do
  newEntity (Position 0, Velocity 1)
  newEntity (Position 1, Velocity 1)
  cmap $ \(Position p, Velocity v) -> Position (v+p)

main :: IO ()
main = initWorld >>= runSystemT game
#+END_SRC

*** TODO Entitas
Entitas is probably the most popular and fully-featured ECS implementation currently available.
There is both a free open-source version and a paid upgrade that features e.g. an improved code generator.
It is a plug-in for the popular Unity game engine, and is therefore necessarily written in C#.

#+BEGIN_SRC cs
[Event(true)]
public sealed class PositionComponent : IComponent {
    [EntityIndex]
    public IntVector2 value;
}

[Event(true)]
public sealed class VelocityComponent : IComponent {
    [EntityIndex]
    public IntVector2 value;
}

public sealed class StepSystem : IExecuteSystem {
    readonly IGroup<GameEntity> _entities;
    public StepSystem(Contexts contexts) {
        _entities = contexts.GetEntities(Matcher<GameEntity>.AllOf(GameMatcher.Position, GameMatcher.Velocity));

    public void Execute() {
        foreach(var e in _entities) {
            var pos = e.position;
            var vel = e.velocity;
            e.ReplacePosition(pos.value + vel.value);
        }
    }
}

public class GameController : MonoBehaviour {
    void Start() {
        var contexts = new Contexts();

        var e1 = contexts.game.CreateEntity();
        var e2 = contexts.game.CreateEntity();

        e1.AddPosition(new Vector2(0,1);
        e2.AddPosition(new Vector2(0,1);
        e1.AddVelocity(new Vector2(0,1);
        e2.AddVelocity(new Vector2(0,1);

        var system = new StepSystem(contexts);
        system.Execute();
    }
}
#+END_SRC

*** TODO specs
/specs/ was written in Rust.
Like ~apecs~, it defines components by declaring the appropriate type class instances, but systems have to be defined explicitly.
#+BEGIN_SRC rust
struct Pos(f32);
struct Vel(f32);

impl Component for Pos {type Storage = VecStorage<Self>;}
impl Component for Vel {type Storage = VecStorage<Self>;}

struct SysA;

impl<'a> System<'a> for SysA {
    type SystemData = (WriteStorage<'a, Pos>, ReadStorage<'a, Vel>);

    fn run(&mut self, (mut pos, vel): Self::SystemData) {
        for (pos, vel) in (&mut pos, &vel).join() {
            pos.0 += vel.0;
}}}

fn main() {
    let mut world = World::new();
    world.register::<Pos>();
    world.register::<Vel>();

    world.create_entity().with(Vel(2.0)).with(Pos(0.0)).build();
    world.create_entity().with(Vel(4.0)).with(Pos(1.6)).build();
    let mut dispatcher = DispatcherBuilder::new().with(SysA, "sys_a", &[]).build();
    dispatcher.dispatch(&mut world.res);
}
#+END_SRC
*** TODO Ecstasy
- References
Finally, I'd be remiss not to mention /Ecstasy/, an ECS in Haskell directly inspired by earlier efforts on apecs.
Where ~apecs~ mimics the imperative ECS libraries that inspired it in both design and performance, Ecstasy focuses on being idiomatic Haskell with immutable data structures.
Furthermore, it uses ~GHC.Generics~ instead of Template Haskell, which apecs' design does not currently allow for.
Ecstasy is still in its infancy, but might prove to be an interesting alternative approach to Haskell ECS.

#+BEGIN_SRC haskell
data Entity' f = Entity
  { pos    :: Component f 'Field (V2 Float)
  , vel    :: Component f 'Field (V2 Float)
  } deriving (Generic)

game :: Entity' 'WorldOf -> Entity' 'WorldOf
game = flip runSystem $ do
  -- integrate velocity into position
  emap $ do
    p <- get pos
    v <- get vel
    pure defEntity'
      { pos = Set $ p + v }

  getWorld
#+END_SRC

** DONE Cool things
Apecs' power comes from exploiting the fact that both Stores and Components can be composed.
We have already seen this in action in e.g. ~newEntity (Position p, Velocity v)~, where two components are combined in a tuple to form a larger component.
In this way, a tuple is essentially a logical conjunction between two components.
We can also do negation: ~cmap (Position p, Not :: Not Velocity) -> Position (p+1)~ will increment the Position of every entity /without/ a Velocity.
Similarly, ~cmap (Position p, Just (Velocity v) :: Maybe Velocity)~ can be used to iterate over all positions, and read their velocities if they have one.

By changing the Storage of a Component, we can add additional behaviour to them.
One example is ~type Storage Position = Cache 100 (Map Position)~, in which the core map is wrapped in a cache of size 100.
This allows us to store most components in fast, fixed-size vectors, and allows apecs to be very fast.
Another example could be adding reactivity to a Store, like keeping a spatial hash of all positions tracked by a Store, or running a System when a condition has been met.
Because Stores instances are defined with respect to some monad, we could even define STM instances, for free atomic parallelism.

Stores can also be used to interface into foreign data stores.
One such example comes in the form of ~apecs-physics~, which allows the user to seamlessly integrate Chipmunk2D, a very fast 2D dynamics system.
** TODO List of Contributions
- Compostable components
- Composable Stores
- DSL
* Implementation
The core of apecs is small enough to look at in its entirety:
#+BEGIN_SRC haskell
newtype Entity = Entity {unEntity :: Int} deriving ...

type family Elem s
class Elem (Storage c) ~ c => Component c where
  type Storage c

newtype SystemT w m a = System {unSystem :: ReaderT w m a} deriving ...

class (Component c, Monad m, Store m (Storage c)) => Has w m c where
  getStore :: SystemT w m (Storage c)

class Monad m => Store m s where
  initStore :: m s
  explSet :: s -> Int -> Elem s -> m ()
  explGet :: s -> Int -> m (Elem s)
  explDestroy :: s -> Int -> m ()
  explMembers :: s -> m (U.Vector Int)
  explExists :: s -> Int -> m Bool
#+END_SRC

Entities are, as mentioned in the introduction, just integers.
They only exist at the System level, and are used as e.g. arguments to the ~get~ and ~set~ Systems.
Because they are just integers, they can also safely be stored and used as references to other entities.
An entity can be said to exist as long as there is at least a single component associated with its ID, but there is no centrally tracked notion of existence.

~Component~ is just a type class dictating the storage of an entity.
The only requirement is that an ~Elem~ of said Store is the entity itself.

~SystemT~ is a Reader monad transformer around some monad ~m~.
The monad argument is where the underlying stores live, and the ~w~ is a collection of references to those stores as we saw in the example.

The main mechanism of reading a store from the ~w~ is the ~Has~ type class, which allows the user to query the store of some component.

And finally, the Store type class.
The Store type class houses most of the actual operations done by apecs, but you generally don't use any of these functions directly.
The implementations of these functions will generally correspond to expected behaviour for maps, but there are no laws requiring the user to do so.
Keeping the ~m~ generic allows us to define instances for monads other than IO, most notably ST and STM.

** Systems
Most systems exposed by apecs are wrappers around the ~Store~ member functions, such as ~get :: forall w m c. Has w m c => Entity -> SystemT w m c~.
The wrapper eliminates the need to supply the ~s~ in ~explGet~ manually.
We can now also define ~cmap(M_)~:
#+BEGIN_SRC haskell
cmap :: forall w m cx cy. (Has w m cx, Has w m cy)
     => (cx -> cy) -> SystemT w m ()
cmap f = do
  sx :: Storage cx <- getStore
  sy :: Storage cy <- getStore
  lift$ do
    sl <- explMembers sx
    U.forM_ sl $ \ e -> do
      r <- explGet sx e
      explSet sy e (f r)
#+END_SRC

This pattern of producing a Store, and then lifting an action into its monad is so common that it has been captured in ~withStore~:
#+BEGIN_SRC haskell
withStore :: forall w m c a. Has w m c => (Storage c -> m a) -> SystemT w m a
withStore f = do
  s :: Storage c <- getStore
  lift$ f s
#+END_SRC

** Stores
The Store instance for Map looks like this:
#+BEGIN_SRC haskell
instance (PrimMonad m) => Store m (Map m c)

type IOMap c = Map IO c
type STMap s c = Map (ST s) c
#+END_SRC
It is the most basic store and will generally behave "as expected".
There are, however, a number of other interesting stores that are less straightforward.
One such example is ~Global~, used by e.g. ~EntityCounter~, whose signature looks like this:
#+BEGIN_SRC haskell
type instance Elem (Global c) = c
instance (PrimMnad m, Monoid c) => Store m (Global c)
#+END_SRC
It is initialized with the monoidal ~mempty~ value, and will always ignore its entity arguments.
There is an entity ~global = Entity (-1)~ used to signal writing to a global value, and by returning this entity when asking for a membership list, we retain sensible ~cmap~ behaviour.
There are a few more maps not documented here, but these can be found in the apecs documentation.

** TODO Laws and safety
Store laws:
1. Every entity in the list of members exists
2. For every entity that exists, get is safe
  
Looking at the type signature for ~get~/~explGet~, we can see that it is possible to generate unsafe behaviour by looking up keys in the map for which there are no entries.
Luckily this is easily dealt with, by casting to ~get :: Entity -> SystemT w m (Maybe c)~.
This is the only unsafe behaviour in apecs, and it exists so users can skip the safety check if they are absolutely sure the lookup is safe, such as in an iteration over the members.

** Instances
It's worth taking a closer look at some of the instances for the core classes.
*** Tuple
There are a number of instances worth taking a look at.
We've already briefly discussed the tuple instance:
#+BEGIN_SRC haskell
instance (Component a, Component b) => Component (a,b) where
  type Storage (a,b) = (Storage a, Storage b)

type instance Elem (a,b) = (Elem a, Elem b)

instance (Has w m a, Has w m b) => Has w m (a,b) where
  getStore = (,) <$> getStore <*> getStore
instance (Store m a, Store m b) => Store m (a,b) where
  initStore = (,) <$> initStore <*> initStore
  explGet (sa,sb) ety = (,) <$> explGet sa ety <*> explGet sb ety
  explSet (sa,sb) ety (xa,xb) = explSet sa ety xa >> explSet sb ety xb
  explExists (sa,sb) ety = (&&) <$> explExists sa ety <*> explExists sb ety
  explMembers (sa,sb) = explMembers sa >>= U.filterM (explExists sb)
  explDestroy (sa,sb) ety = explDestroy sa ety >> explDestroy sb ety
#+END_SRC
Note how when producing a list of members, we first produce a list of members of the first component and then filter using the membership test for the second.
An important consequence of this is that it is generally faster to iterate over the fewest members possible.
For example, if 100 entities have a position but 1000 have a velocity, iterating over ~(Velocity, Position)~ should be about 10 times faster than the other way around.
*** Negation
~Not~ has a special store it uses, the ~NotStore~.
The user will never instantiate this store manually, but instead the underlying store is wrapped in it when using ~getStore~.
#+BEGIN_SRC haskell
data Not a = Not
newtype NotStore s = NotStore s

instance Component c => Component (Not c) where
  type Storage (Not c) = NotStore (Storage c)

instance (Has w m c) => Has w m (Not c) where
  getStore = NotStore <$> getStore

type instance Elem (NotStore s) = Not (Elem s)
instance Store m s => Store m (NotStore s) where
  initStore = NotStore <$> getStore
  explGet _ _ = return Not
  explSet (NotStore sa) ety _ = explDestroy sa ety
  explExists (NotStore sa) ety = not <$> explExists sa ety
  explMembers _ = return mempty
  explDestroy sa ety = explSet sa ety Not
#+END_SRC
~NotStore~'s primary task is to invert the membership test, but the rest of the functions still have sensible implementations.
Now, why is the list of members empty?
There are a number of reasons.
- The laws require only that all entities in the list exist, which is always true for an empty list.
- One possible, correct implementation would return a list of all integers for which it does not hold an entity, but this would obviously be impractically long.
- Another possibility would be a list of all live entities in other stores, but the NotStore does not know about any stores other than the one it is currently wrapping.
- A more general point is that we can never indiscriminately iterate over all entities, as there could easily be millions.
- ~Not~ will generally only occur as part of a tuple to filter out components, and will rarely be asked for its members.
  
~Not~ is especially useful when we use unit constructors, like
#+BEGIN_SRC haskell
data Flying = Flying
instance Component Flying where type Storage Flying = Map Flying
#+END_SRC
Single-constructor components can be used to tag entities, with their presence or absence acting like boolean values.
This allows us to e.g. apply gravity to non-flying entities like this:
#+BEGIN_SRC haskell
cmap $ \(Velocity (V2 x y), Not :: Not Flying) -> Velocity (V2 x (y-1))
#+END_SRC
*** Entity
Finally, ~Entity~ can also be used as a component:
#+BEGIN_SRC haskell
data EntityStore = EntityStore
instance Component Entity where
  type Storage Entity = EntityStore

instance Monad m => (Has w m Entity) where
  getStore = return EntityStore

type instance Elem EntityStore = Entity
instance Monad m => Store m EntityStore where
  initStore = error "Initializing Pseudostore"
  explGet _ ety = return $ Entity ety
  explSet _ _ _ = return ()
  explExists _ _ = return True
  explMembers _ = return mempty
  explDestroy _ _ = return ()
#+END_SRC
This allows expressions like ~cmapM_ $ \(Position p, Entity e) -> liftIO$ print (p,e)~ to print a list of all positions and corresponding entities.
** Note
The above describes the code as it occurs on apecs' ~systemt~ branch.
The difference between it and the main branch is that ~SystemT~ has a monad argument, whereas on the main branch, you will find
#+BEGIN_SRC haskell
newtype System w a = System {unSystem :: ReaderT w IO a}
#+END_SRC
The ~SystemT~ version allows for many cool things (like using the STM monad) and is probably the more idiomatic implementation of the two.
Unfortunately, benchmarks show that this branch is currently over 10 times slower than the master branch.
Because one of apecs main strengths is the fact that its performance is competitive with Rust ECS implementations, the ~system~ branch will not be merged until this is addressed.

* Verification
Wat te verifieren?
* Related Work
Dit is grotendeels al aangepakt in de introductie?
* Conclusion
** Verification
** Future work
- SystemT branch
- Remove Template Haskell? Move to generics?
